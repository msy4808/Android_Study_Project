Toast.makeText(getApplicationContext(), "버튼이 눌렸습니다!!!", Toast.LENGTH_LONG).show();

--> onClick 메서드에서 간단한 메세지를 띄우는 기능

Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://m.naver.com"));
        startActivity(myIntent);

Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("tel:010-0000-1111"));
        startActivity(myIntent);

--> 인텐트기능 : 전달한 값을 받아 해당 값에 맞는 동작을 하는 기능(다음에 더 자세한 설명나옴)

공간가중치 (flex라고 생각하면 편함)

android:layout_weight = "?"  <-- 사용법

HTML에서 flex처럼 해당 공간을 ?의 비율로 설정하여 공간을 할당해줌

뷰 크기 --> 각 단말별 해상도가 다르므로 dp 단위를 사용. 해상도에 비율에 따라 비슷하게 설정되는 장점이 있음

뷰의 위치는 절대값 X --> 과거에 사용되던 방법이지만 지금은 사용하지않음.

XML에서 화면을 구성하지않고 자바코드 상에서 구현가능

--자바코드안에 onCreate()메소드 안에서

LinearLayout mainLayout = new LinearLayout(this);  <-- 리니어레이아웃을 선언해줌
mainLayout.setOrientation(LinearLayout.VERTICAL); <-- 선언한 레이아웃에 방향을 설정해줌

LinearLayout.LayoutParams params = 
		new LinearLayout.LayoutParams(
		LinearLayout.LayoutParams.MATCH_PARENT,
		LinearLayout.LayoutParams.WRAP_CONTENT); <-- 레이아웃안에 추가될 뷰들에 설정할 파라미터 생성

Button btn1 = new Button(this); <-- 버튼 생성
btn1.setText("버튼1"); <-- 버튼에 텍스트 설정
btn1.setLayoutParams(params); <-- 설정한 파라미터를 버튼에 부여
mainLayout.addView(btn1); <-- 버튼을 레이아웃에 추가

setContentView(mainLayout); <-- 레이아웃을 화면에 설정



--프래그먼트

프래그먼트의 사용목적 --> 분할된 화면들을 독립적으로 구성하기 위해서, 분할된 화면드르이 상태를 관리하기 위해서


--메인 프래그먼트
public class MainFragment extends Fragment {
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        ViewGroup view = (ViewGroup) inflater.inflate(R.layout.main_fragment, container,false);
        Button btn1 = view.findViewById(R.id.main_btn);
        btn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                MainActivity main = (MainActivity) getActivity();
                main.onChanged(0);
            }
        });
        return view;
    }
}

--메뉴 프래그먼트
public class MenuFragment extends Fragment {
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        ViewGroup view = (ViewGroup) inflater.inflate(R.layout.menu_fragment, container,false);

        Button btn = view.findViewById(R.id.menu_btn);
        btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                MainActivity main = (MainActivity) getActivity();
                main.onChanged(1);
            }
        });
        return view;
    }
}

--메인 액티비티
public class MainActivity extends AppCompatActivity {
    MainFragment main;
    MenuFragment menu;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        main = (MainFragment) getSupportFragmentManager().findFragmentById(R.id.main_f);
        menu = new MenuFragment();
    }
    public void onChanged(int index) {
        if(index == 0) {
            getSupportFragmentManager().beginTransaction().replace(R.id.container, menu).commit();
        } else if(index == 1) {
            getSupportFragmentManager().beginTransaction().replace(R.id.container,main).commit();
        }
    }
}

--메인 프래그먼트 XML
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/textView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="메인 프래그먼트"
        android:textSize="30dp"
        android:layout_centerInParent="true"
        android:gravity="center"/>

    <Button
        android:id="@+id/main_btn"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerInParent="true"
        android:text="메뉴화면으로"
        android:textSize="30dp" />
</RelativeLayout>

--메뉴 프래그먼트 XML
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/textView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true"
        android:gravity="center"
        android:text="메뉴 프래그먼트"
        android:textSize="30dp" />

    <Button
        android:id="@+id/menu_btn"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="메인화면으로"
        android:textSize="30dp"
        android:layout_alignParentBottom="true" />
</RelativeLayout>

--메인액티비티 XML
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/container">

   <fragment
       android:id="@+id/main_f"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:name="moon.fragment_test.MainFragment"/>
</RelativeLayout>


안드로이드 수명주기

새로운 액티비티
onCreate();
onStart();
onResume();
	
	↓

실행
onPause(); 일시중지(다른 액티비티가 상위로 오게된다면 호출)
onResume(); 일시중지된 액티비티가 다시 실행될때 호출

	↓

중지
onStop(); 중지상태로 변경될때 자동으로 호출됨

	↓
실행
onRestart();
onStart();
onResume(); 중지상태에서 다시 실행상태로 변경될때 호출

	↓
소멸
onDestroy();



각각의 상태 메소드

onCreate() 
액티비티가 처음에 만들어졌을때 호출됨
화면에 보이는 뷰들의 일반적인 상태를 설정하는 부분
이전 상태가 저장되어 있는 경우에는 번들 객체를 참조하여 이전 상태 복원가능
이 메소드 다음에는 항상 onStart() 메소드가 호출됨


onStart()
액티비티가 화면에 보이기 바로 전에 호출됨
액티비티가 화면 상에 보이면 이 메소드 다음에 onResume() 메소드가 호출됨
액티비티가 화면에서 가려지게 되면 이 메소드 다음에 onStop() 메소드가 호출됨


onResume()
액티비티가 사용자와 상호작용하기 바로 전에 호출됨


onRestart()
액티비티가 중지된 이후에 호출되는 메소드로 다시 시작되기 바로 전에 호출됨
이 메소드 다음에는 항상 onStart() 메소드가 호출됨


onPause()
또 다른 액티비티를 시작하려고 할때 호출됨
저장되지 않은 데이터를 저장소에 저장하거나 애니메이션 중인 작업을 중지하는 등의 기능을 수행하는 메소드임
이 메소드가 리턴하기 전에는 다음 액티비티가 시작될수 없으므로 이 작업은 매우 빨리 수행된 후 리턴 되어야함
액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료 할 수있음


onStop()
액티비티가 사용자에게 더 이상 보이지 않을 때 호출됨
액티비티가 소멸되거나 또 다른 액티비티가 화면을 가릴 때 호출됨
액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료 할 수있음


onDestroy()
액티비티가 소멸되어 없어지기 전에 호출됨
이 메소드는 액티비티가 받는 마지막 호출이 됨
액티비티가 애플리케이션에 의해 종료되거나(finish() 메소드 호출) 시스템이 강제로 종료시키는 경우에 호출될수 있음
위의 두가지 경우를 구분할때 isFinishing() 메소드를 이용함
액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료 할 수있음


메인스레드에서만 UI를 그릴수있다
스레드간 통신은 기본적으로 핸들러를 통해 가능
핸들러로 handleMessage()메소드를 오버라이드하여 메세지 수신시 동작할 작업을 코딩한 후
sendMessage() 혹은 sendEmptyMessage()(두 메서드 다 핸들러를 상속받은 객체를 통해 사용)를 통해 메세지를 전달하면 해당 작업을 실행

또한 스레드를 생성하기위해 Thread클래스를 상속할 필요는 없음(스레드의 전체기능을 다 가져옴)
전체를 상속하는게 아닌 Runnable 인터페이스를 implements하여 사용하면 run()메소드 하나만 오버라이드하면 됨(run하나만 가져옴)
RUnnable 인터페이스는 run메소드 하나만을 가지고있음


서비스

안드로이드에서 백그라운드 작업을 위한 구성요소
액티비티는 사용자의게 직접 보여지는 화면을 구성하고
서비스는 그 뒤에서 안보이는 작업을 수행한다
예로 노래를 들으며 웹서핑이 가능하다거나
전화를 하면서 인터넷을 볼수있는 등의 일이 있다


서비스의 3가지 유형
 

1) 백그라운드
백그라운드는 이름 그대로 사용자에게 직접 보이지 않는 작업을 수행한다.

액티비티가 사용자에게 직접 보이는 화면이라면

서비스는 뒤에서 필요한 작업을 수행한다.

애플리케이션을 꺼도 백그라운드 서비스는 계속 수행할 수 있다.

 

2) 바인더
바인딩을 위한 서비스이다.

이름 그대로 여러 구성 요소(예를 들면 Acticity)를 서비스에 바인딩하여

서비스와 상호작용할 수 있다.

클라이언트-서버 유형과 비슷하다고 생각할 수 있다.

액티비티와 서비스는 따로 운영될 수 있지만

서로 바인딩하여 통신할 수도 있다.

bindService()를 호출하여 사용한다.

바인딩이 해제되면 해당 서비스는 소멸된다.

 

3) 포그라운드
서비스는 포그라운드로도 실행할 수 있다.

포그라운드는 이름 그대로 사용자에게 직접 보이는 작업을 수행한다.

오디오 앱을 예로 들면 트랙을 재생할 때 포그라운드 서비스를 사용한다.

포그라운드인데 왜 서비스냐? 사용자가 다른 앱을 사용중이어도 계속해서 실행되도록 하기 때문이다.

3. 서비스의 선언
 

서비스는 activity처럼 Manifest에서 선언해주어야 한다.

이때 application의 하위 요소로 선언해주면 된다.

 

<manifest>

   <application>

      <service android:name=".MyService"/>

   </application>

</manifest>

 

서비스는 다른 애플리케이션과도 상호작용할 수 있는데

Manifest에서 서비스를 비공개로 선언하고 다른 애플리케이션으로부터의 액세스를 차단할 수도 있다.

 

android:exported="false"를 추가하면

서비스를 본인의 앱에서만 사용 가능하게 할 수 있다.

android:description 특성을 추가해서 서비스에 대한 설명을 기재할 수도 있다.




4. 서비스의 기본 콜백 메소드
 

1) onStartCommand()
서비스를 시작하도록 요청하는 메소드이다.

서비스를 실행하려는 곳(예를 들면 Activity)에서 startService()를 써서 호출된다.

 

이 메소드가 실행되면 서비스가 시작되고 백그라운드에서 무한히 실행될 수 있다.

서비스를 중단하는 것은 stopSelf() 또는 stopService()를 써서 호출하면 된다.

 

바인딩만 제공하고자 하는 경우에는 onStartCommand()를 구현하지 않아도 된다.

 

 

2) onBind()
다른 구성 요소와 서비스를 바인딩하려는 경우에 호출한다.

바인딩을 실행하려는 곳(예를 들면 Activity)에서 bindService()를 써서 호출된다.

 

구현을 할 때는 Interface를 제공해야 한다.

return으로 IBinder를 반환하면 된다.

 

이 메소드는 항상 구현해야 한다.

구현을 하는데 바인딩을 하지 않으면 return값으로 null을 반환하면 된다.

 

 

3) onCreate()
onStartCommand() 또는 onBind()를 호출하기 전에 호출한다.

 

onStartComannd() 또는 onBind()에서 서비스를 실행하거나 바인딩을 하고 나면

서비스가 계속해서 실행되고 있는 중이 되기 때문에

일회성으로 실행되며, 서비스가 이미 실행 중이면 onCreate()는 호출되지 않는다.

 

 

4) ondestroy()
서비스를 소멸시킬 때 호출한다.

각종 리소스를 정리하기 위해 구현해야 한다.

 

 

 

 

 

5. 서비스의 호출과 소멸
 

1) startService() 서비스 호출
한 구성 요소(예를 들면 Activity)에서

startService()를 써서 서비스를 호출하면

onStartCommand()가 호출되고

서비스가 중단되기 전까지는 서비스를 실행중인 상태로 유지한다.

 

서비스를 중단하는 방법은

stopSelf()로 스스로 중단하거나,

다른 구성 요소(예를 들면 Activity)에서 stopService()를 써서 호출할 수 있다.

 

 

2) bindService() 바인딩 호출
한 구성 요소(예를 들면 Activity)에서

bindService()를 써서 서비스를 호출하면

해당 서비스는 해당 구성 요소가 바인딩된 경우에만 실행된다.

서비스가 모든 바인딩이 해제되면 시스템에 의해 소멸된다.

 

 

3) 서비스 소멸
안드로이드 시스템이 서비스를 강제로 소멸하는 경우는,

메모리 부족으로 인해 리소스를 정리하는 경우에 국한된다.

 

서비스가 강제로 소멸할 가능성은 다음과 같다.

- 서비스가 포그라운드에서 실행되는 경우 -> 소멸 가능성 희박함

- 서비스가 바인딩된 경우 -> 소멸 가능성 적음

- 서비스가 백그라운드에서 장시간 실행 중 -> 소멸 가능성 높음

 

 

4) 서비스 소멸 후 재시작
서비스가 시스템에 의해 소멸된 경우,

서비스가 다시 시작할 여부는

onStartCommand()의 return값에 따라 달라질 수 있다.

 

onStartComman()는 3가지 반환 값을 가질 수 있다.

 

(1) START_REDELIVER_INTENT
시스템이 서비스를 중단하면 서비스를 다시 생성한다.

그리고 이 서비스에 전달된 마지막 인텐트로 onStartCommand()를 호출한다.

모든 보류 인텐트가 차례로 전달된다.

파일 다운로드와 같은 서비스에 적합하다.

 

(2) START_STICKY
시스템이 서비스를 중단하면 서비스를 다시 생성한다.

마지막 인텐트를 전달하지 않고 null 인텐트로 onStartcommand()를 호출한다.

명령을 실행하진 않지만 작업을 기다리는 미디어 플레이어와 같은 서비스에 적합하다.

 

(3) START_NOT_STICKY
시스템이 서비스를 중단하면 서비스를 재생성하지 않는다.

다시 시작하려는 경우에 적합하다.

public class MyService extends Service {
 
    @Override // 서비스가 최초 생성될 때만 호출
    public void onCreate() {
    }
 
    @Override // startService()로 서비스를 시작할 때 호출
    public int onStartCommand(Intent intent, int flags, int startId) { 
 
        return START_STICKY;
    }
 
    @Override // bindService()로 바인딩을 실행할 때 호출
    public IBinder onBind(Intent intent) {
 
        return mBinder;
    }
 
    @Override // unbindService()로 바인딩을 해제할 때 호출
    public boolean onUnbind(Intent intent) {
 
        return mAllowRebind;
    }
 
    @Override // 이미 onUnbind()가 호출된 후에 bindService()로 바인딩을 실행할 때 호출
    public void onRebind(Intent intent) {
 
    }
 
    @Override // 서비스가 소멸될 때 호출
    public void onDestroy() {
 
    }
 
}


8. 서비스의 시작과 중단
 

1) 서비스의 시작
서비스는 다른 구성 요소(예를 들어 Activity)에서

startService()를 써서 서비스의 onStartCommand()를 호출하면서 시작된다.

호출할 때는 Intent를 전달하는데, 예를 들어 다음과 같이 호출할 수 있다.

 

startService(new Intent(getApplicationContext(), MyService.class));

 

이 호출을 서비스의 onStartcommand()에서 받는다.

 

서비스가 시작되면 이를 호출한 구성 요소와 독립적인 수명 주기를 가진다.

즉 서비스는 백그라운드에서 무한히 실행될 수 있고,

서비스를 호출한 구성 요소가 소멸되어도 계속 실행될 수 있다.

 

 

2) 서비스의 중단
서비스는 수명 주기(LifeCycle)를 직접 관리해야 한다.

즉, 시스템은 기본적으로는 서비스를 중단이나 소멸시키지 않는다.

stopSelf()로 스스로 중지하거나,

다른 구성 요소(예를 들어 Activity)에서 stopService()를 써서 소멸시킬 수 있다.

 

stopService(new Intent(getApplicationContext(), MyService.class));

 

 

 

3) 액티비티 내에서만 실행 및 중단하는 법
서비스를 액티비티가 실행중인 동안에만 작동하도록 하려면

액티비티의 onCreate()에서 서비스를 생성하고

onStart()에서 서비스스를 실행하고

onStop()에서 서비스를 중단하면 된다.


9. 바인딩 서비스 생성

바인딩된 서비스는 bindService()를 호출하여

다른 구성 요소를 서비스에 바인딩할 수 있다.

 

바인딩된 서비스를 생성하려면 onBind() 콜백 메소드를 구현하여

서비스와의 통신을 위한 Interface를 정의하는 IBinder를 return해야 한다.

그렇게 하면 다른 구성 요소가 bindService()를 호출하여 

해당 Interface를 검색하고 서비스에 있는 메소드를 호출할 수 있다.

 

서비스는 바인딩된 구성 요소를 돕기 위해 존재하는 것이기 때문에

구성 요소가 소멸되면 시스템이 서비스도 소멸시킨다.

그래서 바인딩된 서비스는 기본적으로 직접 중단하지 않아도 된다.

 

여러 구성 요소가 한 서비스에 바인딩될 수 있다.

구성 요소는 unbindService()를 호출하여 서비스에 바인딩을 해제할 수 있고

서비스에 바인딩된 구성 요소가 하나도 남지 않게 되면

서비스가 서비스를 소멸시킨다.



안드로이드의 4대 구성요소(컴포넌트)

-액티비티
-서비스
-브로그캐스트 리시버
-컨텐트 프로바이더

이 각각의 컴포넌트간의 통신을 맡는 것이 Intent이다

Intent의 통신 방법은 두가지

-명시적 Intent
-암시적 Intent

명시적 Intent

-명시적 Intent는 가장 많이 보는 방법입니다. 앱의 화면 전환을 할때 사용

Intent intent = new Intent(A_Activity.this, B_Activity.class);
startActivity(intent);

현재 액티비티(A)에서 다른 액티비티(B)를 호출할 때 사용됩니다

물론 이런 방식으로 사용하기위해선 매니패스트에서 액티비티를 정의를 해주어야 함

<activity android:name=".B_Activity">    <-- 매니패스트에서 액티비티 정의하는 법

또한 Intent에서 액티비티를 호출할 때 데이터를 전달 또는 리턴 받을 수 있음

-A에서 B로 데이터를 전달시

Intent intent = new Intent(A_Activity.this, B_Activity.class);
intent.putExtra("kay", "데이터 11111");  <-- 전달할 데이터를 kay / value 형식으로 Intent에 저장함
startActivity(intent);

이렇게 B로 데이터를 전달하면 B에서 받을수 있음

Intent b_Intent = getIntent();  <-- Intent를 getIntent() 로 가져옴

String value = b_Intent.getStringExtra("kay");  <-- A에서 전달할때 지정한 key값으로 데이터를 가져옴

-A에서 startActivityForResult() 메소드로 B를 호출하고 B에서 onActivityResult() 로 리턴값을 받을수 있음

Intent intent = new Intent(A_Activity.this, B_Activity.class);
startActivityForResult(intent, 100);  <-- B를 호출 시 100이란 값을 넘겨줌


-B_Activity.class

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode){   
        case 100:   <-- A에서 받은 값이 100이라면 case문 실행
            if(data.getExtras() != null){
                String str = data.getStringExtra("resultKey");
                result01.setText("startAcitivtyForResult() 리턴값 받기: " + str);
            }
            break;
    }
    super.onActivityResult(requestCode, resultCode, data);
}


암시적 Intent

-암시적 Intent는 Intent의 Action에 따라 해당하는 적합한 애플리케이션의 클래스를 호출함.
-이때 하나가 아니라 여러 개가 호출이 될 수있음
-암시적 Intent는 웹브라우저의 호출, 이메일 전송, 전화앱으로 통화 등등이 있음


-웹브라우저 Intent 호출

Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://m.naver.com"));
startActivity(intent);   <-- 웹브라우저가 열리며 naver.com으로 이동


-이메일 전달 Intent 호출

Intent intent = new Intent(Intent.ACTION_SEND);
intent.setType("text/plain");
intent.putExtra(Intent.EXTRA_EMAIL, "sampleXXX@sampleXXX.com");
intent.putExtra(Intent.EXTRA_SUBJECT, "전달할 이메일 제목");
intent.putExtra(Intent.EXTRA_TEXT, "전달할 내용");
startActivity(Intent.createChooser(intent, "Choose Email"));


-전화 Intent 호출

Intent intent = new Intent(Intent.ACTION_VIEW,Uri.parse("tel:010-0000-0000"));
startActivity(intent);
